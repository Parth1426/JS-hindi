//console.log(2>1);
//console.log(2>=1);
//console.log(2<1);
//console.log(2==1);
//console.log(2!=1);


//console.log("2">1);//output true
//console.log("02">1);//output true


// console.log(null>0);//output false
// console.log(null==0);//false
// console.log(null >= 0);//true

//the reason is that an equality check == and comparisons > < >= <= word differemtly
//comparisons convert null to a number , treating it as 0 thats why null>=0 is true and null>0 i false


//console.log(undefined>0);
//console.log(undefined==0);
//console.log(undefined<0);
//all give output as false

//console.log("2"==2);//true
console.log("2"===2);//false checks datatype also

//***************************************************************************
//stack(primitive)  heap(non primitive) memory
let myname= "parth"
let yoursname=myname
yoursname="sharyu"

//console.log(yoursname)
//console.log(myname)
//in stack memory copy is been made so if the name changes actual value does not change it remains same 



let userone ={
    email: "parth@google.com",
    upi : "userybl",
}

let usertwo=userone

usertwo.email = "sharyu@dr"

console.log(userone.email);//sharyu@dr
console.log(usertwo.email);//sharyu@dr

// here in heap direct reference is given to the particular name if it changes then others having same references also changes